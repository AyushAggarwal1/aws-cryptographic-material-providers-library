# Code generated by smithy-python-codegen DO NOT EDIT.

from Wrappers import Option_None, Option_Some
from aws_cryptography_primitives_internaldafny_types import (
    AESDecryptInput_AESDecryptInput as DafnyAESDecryptInput,
    AESDecryptOutput_AESDecryptOutput as DafnyAESDecryptOutput,
    AESEncryptInput_AESEncryptInput as DafnyAESEncryptInput,
    AESEncryptOutput_AESEncryptOutput as DafnyAESEncryptOutput,
    AesKdfCtrInput_AesKdfCtrInput as DafnyAesKdfCtrInput,
    AesKdfCtrOutput_AesKdfCtrOutput as DafnyAesKdfCtrOutput,
    DigestInput_DigestInput as DafnyDigestInput,
    DigestOutput_DigestOutput as DafnyDigestOutput,
    ECDSASignInput_ECDSASignInput as DafnyECDSASignInput,
    ECDSASignOutput_ECDSASignOutput as DafnyECDSASignOutput,
    ECDSAVerifyInput_ECDSAVerifyInput as DafnyECDSAVerifyInput,
    ECDSAVerifyOutput_ECDSAVerifyOutput as DafnyECDSAVerifyOutput,
    GenerateECDSASignatureKeyInput_GenerateECDSASignatureKeyInput as DafnyGenerateECDSASignatureKeyInput,
    GenerateECDSASignatureKeyOutput_GenerateECDSASignatureKeyOutput as DafnyGenerateECDSASignatureKeyOutput,
    GenerateRSAKeyPairInput_GenerateRSAKeyPairInput as DafnyGenerateRSAKeyPairInput,
    GenerateRSAKeyPairOutput_GenerateRSAKeyPairOutput as DafnyGenerateRSAKeyPairOutput,
    GenerateRandomBytesInput_GenerateRandomBytesInput as DafnyGenerateRandomBytesInput,
    GenerateRandomBytesOutput_GenerateRandomBytesOutput as DafnyGenerateRandomBytesOutput,
    GetRSAKeyModulusLengthInput_GetRSAKeyModulusLengthInput as DafnyGetRSAKeyModulusLengthInput,
    GetRSAKeyModulusLengthOutput_GetRSAKeyModulusLengthOutput as DafnyGetRSAKeyModulusLengthOutput,
    HMacInput_HMacInput as DafnyHMacInput,
    HMacOutput_HMacOutput as DafnyHMacOutput,
    HkdfExpandInput_HkdfExpandInput as DafnyHkdfExpandInput,
    HkdfExpandOutput_HkdfExpandOutput as DafnyHkdfExpandOutput,
    HkdfExtractInput_HkdfExtractInput as DafnyHkdfExtractInput,
    HkdfExtractOutput_HkdfExtractOutput as DafnyHkdfExtractOutput,
    HkdfInput_HkdfInput as DafnyHkdfInput,
    HkdfOutput_HkdfOutput as DafnyHkdfOutput,
    KdfCtrInput_KdfCtrInput as DafnyKdfCtrInput,
    KdfCtrOutput_KdfCtrOutput as DafnyKdfCtrOutput,
    RSADecryptInput_RSADecryptInput as DafnyRSADecryptInput,
    RSADecryptOutput_RSADecryptOutput as DafnyRSADecryptOutput,
    RSAEncryptInput_RSAEncryptInput as DafnyRSAEncryptInput,
    RSAEncryptOutput_RSAEncryptOutput as DafnyRSAEncryptOutput,
    RSAPrivateKey_RSAPrivateKey as DafnyRSAPrivateKey,
    RSAPublicKey_RSAPublicKey as DafnyRSAPublicKey,
)
import module_

from .errors import (
    AwsCryptographicPrimitivesError,
    CollectionOfErrors,
    OpaqueError,
    ServiceError,
)
from .models import (
    AESDecryptInput,
    AESDecryptOutput,
    AESEncryptInput,
    AESEncryptOutput,
    AES_GCM,
    AesKdfCtrInput,
    AesKdfCtrOutput,
    DigestInput,
    DigestOutput,
    ECDSASignInput,
    ECDSASignOutput,
    ECDSAVerifyInput,
    ECDSAVerifyOutput,
    GenerateECDSASignatureKeyInput,
    GenerateECDSASignatureKeyOutput,
    GenerateRSAKeyPairInput,
    GenerateRSAKeyPairOutput,
    GenerateRandomBytesInput,
    GenerateRandomBytesOutput,
    GetRSAKeyModulusLengthInput,
    GetRSAKeyModulusLengthOutput,
    HMacInput,
    HMacOutput,
    HkdfExpandInput,
    HkdfExpandOutput,
    HkdfExtractInput,
    HkdfExtractOutput,
    HkdfInput,
    HkdfOutput,
    KdfCtrInput,
    KdfCtrOutput,
    RSADecryptInput,
    RSADecryptOutput,
    RSAEncryptInput,
    RSAEncryptOutput,
)


import Wrappers
import asyncio
import aws_cryptography_primitives_internaldafny_types
import aws_cryptography_primitives.smithygenerated.client as client_impl

def smithy_error_to_dafny_error(e: ServiceError):
    if isinstance(e, AwsCryptographicPrimitivesError):
        return aws_cryptography_primitives_internaldafny_types.Error_AwsCryptographicPrimitivesError(message=e.message)

    if isinstance(e, CollectionOfErrors):
        return aws_cryptography_primitives_internaldafny_types.Error_CollectionOfErrors(message=e.message, list=e.list)

    if isinstance(e, OpaqueError):
        return aws_cryptography_primitives_internaldafny_types.Error_Opaque(obj=e.obj)

class AtomicPrimitivesShim(aws_cryptography_primitives_internaldafny_types.IAwsCryptographicPrimitivesClient):
    def __init__(self, _impl: client_impl) :
        self._impl = _impl

    def GenerateRandomBytes(self, input: DafnyGenerateRandomBytesInput) -> DafnyGenerateRandomBytesOutput:
        unwrapped_request: GenerateRandomBytesInput = GenerateRandomBytesInput(length=input.length,
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_random_bytes(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateRandomBytesOutput(data=wrapped_response.data,
        ))

    def Digest(self, input: DafnyDigestInput) -> DafnyDigestOutput:
        unwrapped_request: DigestInput = DigestInput(digest_algorithm=input.digestAlgorithm,
        message=input.message,
        )
        try:
            wrapped_response = asyncio.run(self._impl.digest(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyDigestOutput(digest=wrapped_response.digest,
        ))

    def HMac(self, input: DafnyHMacInput) -> DafnyHMacOutput:
        unwrapped_request: HMacInput = HMacInput(digest_algorithm=input.digestAlgorithm,
        key=input.key,
        message=input.message,
        )
        try:
            wrapped_response = asyncio.run(self._impl.h_mac(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyHMacOutput(digest=wrapped_response.digest,
        ))

    def HkdfExtract(self, input: DafnyHkdfExtractInput) -> DafnyHkdfExtractOutput:
        unwrapped_request: HkdfExtractInput = HkdfExtractInput(digest_algorithm=input.digestAlgorithm,
        salt=input.salt.UnwrapOr(None),
        ikm=input.ikm,
        )
        try:
            wrapped_response = asyncio.run(self._impl.hkdf_extract(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyHkdfExtractOutput(prk=wrapped_response.prk,
        ))

    def HkdfExpand(self, input: DafnyHkdfExpandInput) -> DafnyHkdfExpandOutput:
        unwrapped_request: HkdfExpandInput = HkdfExpandInput(digest_algorithm=input.digestAlgorithm,
        prk=input.prk,
        info=input.info,
        expected_length=input.expectedLength,
        )
        try:
            wrapped_response = asyncio.run(self._impl.hkdf_expand(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyHkdfExpandOutput(okm=wrapped_response.okm,
        ))

    def Hkdf(self, input: DafnyHkdfInput) -> DafnyHkdfOutput:
        unwrapped_request: HkdfInput = HkdfInput(digest_algorithm=input.digestAlgorithm,
        salt=input.salt.UnwrapOr(None),
        ikm=input.ikm,
        info=input.info,
        expected_length=input.expectedLength,
        )
        try:
            wrapped_response = asyncio.run(self._impl.hkdf(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyHkdfOutput(okm=wrapped_response.okm,
        ))

    def KdfCounterMode(self, input: DafnyKdfCtrInput) -> DafnyKdfCtrOutput:
        unwrapped_request: KdfCtrInput = KdfCtrInput(digest_algorithm=input.digestAlgorithm,
        ikm=input.ikm,
        expected_length=input.expectedLength,
        purpose=input.purpose.UnwrapOr(None),
        nonce=input.nonce.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.kdf_counter_mode(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyKdfCtrOutput(okm=wrapped_response.okm,
        ))

    def AesKdfCounterMode(self, input: DafnyAesKdfCtrInput) -> DafnyAesKdfCtrOutput:
        unwrapped_request: AesKdfCtrInput = AesKdfCtrInput(ikm=input.ikm,
        expected_length=input.expectedLength,
        nonce=input.nonce.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.aes_kdf_counter_mode(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyAesKdfCtrOutput(okm=wrapped_response.okm,
        ))

    def AESEncrypt(self, input: DafnyAESEncryptInput) -> DafnyAESEncryptOutput:
        unwrapped_request: AESEncryptInput = AESEncryptInput(enc_alg=AES_GCM(key_length=input.encAlg.keyLength,
        tag_length=input.encAlg.tagLength,
        iv_length=input.encAlg.ivLength,
        ),
        iv=input.iv,
        key=input.key,
        msg=input.msg,
        aad=input.aad,
        )
        try:
            wrapped_response = asyncio.run(self._impl.aes_encrypt(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyAESEncryptOutput(cipherText=wrapped_response.cipher_text,
        authTag=wrapped_response.auth_tag,
        ))

    def AESDecrypt(self, input: DafnyAESDecryptInput) -> DafnyAESDecryptOutput:
        unwrapped_request: AESDecryptInput = AESDecryptInput(enc_alg=AES_GCM(key_length=input.encAlg.keyLength,
        tag_length=input.encAlg.tagLength,
        iv_length=input.encAlg.ivLength,
        ),
        key=input.key,
        cipher_txt=input.cipherTxt,
        auth_tag=input.authTag,
        iv=input.iv,
        aad=input.aad,
        )
        try:
            wrapped_response = asyncio.run(self._impl.aes_decrypt(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyAESDecryptOutput(plaintext=wrapped_response.plaintext,
        ))

    def GenerateRSAKeyPair(self, input: DafnyGenerateRSAKeyPairInput) -> DafnyGenerateRSAKeyPairOutput:
        unwrapped_request: GenerateRSAKeyPairInput = GenerateRSAKeyPairInput(length_bits=input.lengthBits,
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_rsa_key_pair(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateRSAKeyPairOutput(publicKey=DafnyRSAPublicKey(lengthBits=wrapped_response.public_key.length_bits,
        pem=wrapped_response.public_key.pem,
        ),
        privateKey=DafnyRSAPrivateKey(lengthBits=wrapped_response.private_key.length_bits,
        pem=wrapped_response.private_key.pem,
        ),
        ))

    def GetRSAKeyModulusLength(self, input: DafnyGetRSAKeyModulusLengthInput) -> DafnyGetRSAKeyModulusLengthOutput:
        unwrapped_request: GetRSAKeyModulusLengthInput = GetRSAKeyModulusLengthInput(public_key=input.publicKey,
        )
        try:
            wrapped_response = asyncio.run(self._impl.get_rsa_key_modulus_length(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGetRSAKeyModulusLengthOutput(length=wrapped_response.length,
        ))

    def RSADecrypt(self, input: DafnyRSADecryptInput) -> DafnyRSADecryptOutput:
        unwrapped_request: RSADecryptInput = RSADecryptInput(padding=input.padding,
        private_key=input.privateKey,
        cipher_text=input.cipherText,
        )
        try:
            wrapped_response = asyncio.run(self._impl.rsa_decrypt(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyRSADecryptOutput(plaintext=wrapped_response.plaintext,
        ))

    def RSAEncrypt(self, input: DafnyRSAEncryptInput) -> DafnyRSAEncryptOutput:
        unwrapped_request: RSAEncryptInput = RSAEncryptInput(padding=input.padding,
        public_key=input.publicKey,
        plaintext=input.plaintext,
        )
        try:
            wrapped_response = asyncio.run(self._impl.rsa_encrypt(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyRSAEncryptOutput(cipherText=wrapped_response.cipher_text,
        ))

    def GenerateECDSASignatureKey(self, input: DafnyGenerateECDSASignatureKeyInput) -> DafnyGenerateECDSASignatureKeyOutput:
        unwrapped_request: GenerateECDSASignatureKeyInput = GenerateECDSASignatureKeyInput(signature_algorithm=input.signatureAlgorithm,
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_ecdsa_signature_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateECDSASignatureKeyOutput(signatureAlgorithm=wrapped_response.signature_algorithm,
        verificationKey=wrapped_response.verification_key,
        signingKey=wrapped_response.signing_key,
        ))

    def ECDSASign(self, input: DafnyECDSASignInput) -> DafnyECDSASignOutput:
        unwrapped_request: ECDSASignInput = ECDSASignInput(signature_algorithm=input.signatureAlgorithm,
        signing_key=input.signingKey,
        message=input.message,
        )
        try:
            wrapped_response = asyncio.run(self._impl.ecdsa_sign(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyECDSASignOutput(signature=wrapped_response.signature,
        ))

    def ECDSAVerify(self, input: DafnyECDSAVerifyInput) -> DafnyECDSAVerifyOutput:
        unwrapped_request: ECDSAVerifyInput = ECDSAVerifyInput(signature_algorithm=input.signatureAlgorithm,
        verification_key=input.verificationKey,
        message=input.message,
        signature=input.signature,
        )
        try:
            wrapped_response = asyncio.run(self._impl.ecdsa_verify(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyECDSAVerifyOutput(success=wrapped_response.success,
        ))
